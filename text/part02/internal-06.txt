%FILE internal/internal-06.html
%LASTMOD
%KEY pgsql-internal06

%TITLE トランザクションIDと同時実行制御

<font color="#ff0000">
<p>
今読むと記述が甘い。間違いもある。
</p>
</font>

<p>
PostgreSQLの同時実行制御と、その中核的概念であるトランザクションID(XID)について説明します。
</p>

%CHAPTER PostgreSQLのトランザクションID(XID)

<p>
トランザクションID(XID)はトランザクション管理の根幹を担う重要な値です。
PostgreSQLに限らず、すべてのDBMSが独自に実装しています。
</p>

<p>
PostgreSQLのXIDは32[bit]の符号無し整数で、0から2^32-1(約42億9千万)までの範囲の値をとります([<脚注16>])。
トランザクションが開く毎にXIDが発行され、その値は1ずつ増えていきます。
<br>
ここで32[bit]というXIDのサイズが問題になります。実運用では42億9千万トランザクションを超えて稼働しつづけることも稀ではありません。
単純にXIDの大小関係で過去と未来を識別すると、(42億9千万トランザクション発行した後に)XIDが2サイクル目に入ってもう一度小さな値を使いはじめた瞬間に、トランザクション管理が破綻します。
<br>
この問題を避けるため、PostgreSQLは2つの工夫がなされています。
</p>

<ol>
<li>無限の過去を意味するXID=2を導入</li>
<p>
VACUUM処理時、
現在のXIDより数千万(パラメータvacuum_freeze_max_ageで設定)以前の(トランザクション処理が終了した)XIDをすべて"2"につけ換え、
"無限の過去のデータ"として保存し直す。
これを「FREEZE処理」という。
<p>

<li> XIDの過去と未来の識別方法を変更</li>
<p>
最大値(2^32-1)の次のXIDは3、次は4、という具合にXIDを循環させて、32bitの整数空間を繰り返し利用する。そして、あるXIDにとって過去のXIDとは、そのXIDよりも21億(正確には2^31-1)以前の値と解釈する(未来のXIDとは21億先までの値)。
</p>

</ol>


<p>
よって定期的にVACUUM処理を行い、どのトランザクションからも操作されなくなったタプルのXIDを"凍結"していれば、XIDが3から2^32-1の範囲を循環しながら、トランザクション管理は破綻なく続きます。
<br>
VACUUMにおけるFREEZE処理は[<2-07>]で解説します。
</p>


<blockquote><table BORDER="1"><tr><td>脚注16</td><td>
<p>
本書はLOCKの仕組みを省略したので触れませんが、
内部的にLOCKの処理を補助するため"VIRTUAL TRANSACTION ID"という値も用います。
詳細は、src/backend/storage/lmgr/READMEを参照してください。
</p>
</td></tr></table></blockquote>



%CHAPTER MVCCによる同時実行制御

<p>
PostgreSQLをはじめ現代の多くのRDBMSは、同時実行制御の方式としてMVCC(Multi-Version Concurrency Control: 多版式同時実行制御)を採用しています([<脚注17>])。
<br>
MVCCにもいくつかの実装方式があり、PostgreSQLが採用しているのは追記型です[<脚注18>]。
</p>


<blockquote><table BORDER="1"><tr><td>脚注17</td><td>
<p>
他の方式としては、ロックを使った同時実行制御があります。これはDB2やSybaseなど古くから実装されたシステムに多い方式です。
</p>
</td></tr></table></blockquote>


<blockquote><table BORDER="1"><tr><td>脚注18</td><td>
SQLiteも追記型MVCCです。MySQLのInnoDBストレージエンジンやOracleはロールバックセグメント型MVCCです。
</td></tr></table></blockquote>

<p>
追記型とは、データの挿入(INSERT)だけでなく更新(UPDATE)のときも、
古いデータを無効にするだけで削除は行わず、新たにデータを追加するデータ管理方法です。
</p>


<p>
簡単に追記型を説明します([<図2-27>])。詳細は後述します。
</p>


<table border=1>
<caption>[<図2-27>] 追記型MVCCの仕組み</caption>
<tr><td>
<left>
<img src="./fig-2-06-01.jpg"><br>
</left>
</td></tr></table>

<blockquote>

<table><tr>
<td valign="top">[1]</td> 
<td>
ユーザAとBが同じテーブルにアクセスする。
ユーザAが先にトランザクションを開始し、そのトランザクションID(XID)は100である。ユーザBのXIDは101である。
</td>

</tr><tr>

<td valign="top">[2]</td>
<td>
ユーザAがテーブルのデータを更新する。
このとき古いデータタプルを削除せず、新しいデータタプルをデータ領域に追記する。
</td>

</tr><tr>

<td valign="top">[3]</td>

<td>
ユーザAはまだトランザクションをコミットしていないので、
ユーザBがテーブル検索するとユーザAの更新は反映されず、
ユーザBのトランザクション開始時点のデータが見える。
<br>
自分がどのように見えるかは、データを更新したXIDと自身のXIDとの比較で分かる。
</td>

</tr><tr>

<td valign="top">[4]</td>

<td>
ユーザAとBがどちらもトランザクションをコミットすると、
更新された古いデータタプルは不要になる。
更新毎に不要なタプルが溜っていくので、これを削除して空き領域を作る機構が必要になる。
</td>

</tr></table>


</blockquote>

<p>
追記型はデータが際限なく増えていくので、
不要なデータタプルを回収する機構が必要です。その機構を「VACUUM」と呼びます。
<br>
データタプルの追記は、次々と新しいブロックに追記するのでなく、
空き領域のあるブロックに追記し、無闇にファイルサイズが大きくなることを防がねばなりません。
空き領域を効率的に捜し出すために、空き領域マップ(FSM: Free Space Map)があります。
</p>

<p>
VACUUMと空き領域マップは[<2-07>]で解説します。
</p>


%CHAPTER ヒープタプルの構造

<p>
追記型MVCCを理解するために必要となる、ヒープタプル(レコードデータ)の構造を説明します。
</p>

<p>
ヒープタプルのヘッダ部分は構造体
<a href="javascript:void(0)" id="category_HeapTupleHeaderData" onclick="show('HeapTupleHeaderData');">HeapTupleHeaderData</a>
で定義されています[<脚注19>]。
これを図示すると[<図2-28>]のようになります。
</p>
<div id="layer_HeapTupleHeaderData" style="display: none;position:relative;margin-left:15pt" class="close">
%INCLUDE HeapTupleHeaderData.inc
</div> 


<blockquote><table BORDER="1"><tr><td>脚注19</td><td>
<p>
HeapTupleHeaderDataの定義はsrc/include/access/htup.h。
</p>
</td></tr></table></blockquote>


<table border=1>
<caption>[<図2-28>] ヒープタプルの構造<br></caption>
<tr><td>
<left>
<img src="./fig-2-06-02.jpg"><br>
</left>
</td></tr></table>

<p>
ここでは、以降の説明で必要なデータ項目のみ説明します。
</p>

<table border=1>
<tr bgcolor="#cccccc">
<th>項目</th>	<th>説明</th>
</tr><tr>
<td>t_xmin</td>	<td>このタプルを追記したXID</td>
</tr><tr>
<td>t_xmax</td>	<td>このタプルを削除、もしくは更新したXID</td>
</tr><tr>
<td>t_cid</td>	<td>そのトランザクション内で、何番目の追記か</td>
</tr><tr>
<td>t_tcid</td>	<td>追記された新しいタプルへのポインタ</td>
</table>

<p>
これら以外のデータについて、詳細はソースコードのコメントを参照してください。
たとえばt_infomaskはそのタプルがNULLを持つか否かなど様々な情報を保持しています。
</p>


%CHAPTER 追記型MVCC

<p>
追記型MVCCの動作を説明します。
</p>

<p>
はじめに単一トランザクション内でのタプルの追記について説明します。その際、説明を容易にするため、このセクションでのみ使用する表記法も説明します。
<br>
次に２つのトランザクションでの同時実行制御について説明します。
</p>

%SECTION 単一トランザクション内でのデータの追加、更新

<p>
まず、このセクションでのみ使用するタプルの表記法を示します([<図2-29>])。
</p>

<table border=1>
<caption>[<図2-29>] ブロック内のタプルの表記法(1)</caption>
<tr><td>
<left>
<img src="./fig-2-06-03.jpg"><br>
</left>
</td></tr></table>


<p>
[<図2-29>](1)は1レコードしかデータを持たないテーブルtblのブロックです。
<br>
現時点の値'A'はXIDが90のときにINSERTされたとします。
このタプルの状態を、説明に必要な部分だけ取り出して[<図2-29>](2)のように表現します。
t_xminにはこのタプルを書き込んだトランザクションのXIDが書かれています。
このタプルはまだ更新されていないのでt_maxには値がありません。
</p>

<p>
次に、XID=100のトランザクションがこのデータを更新したとします([<図2-30>])。
</p>

<table border=1>
<caption>[<図2-30>] ブロック内のタプルの表記法(2)</caption>
<tr><td>
<left>
<img src="./fig-2-06-04.jpg"><br>
</left>
</td></tr></table>


<p>
新たにタプルが追記され、タプルは計２つになります。
<br>
[<図2-30>](2)において、先のタプルは更新されたので、t_maxには更新したトランザクションのXID(100)が書かれています。
またt_ctidには新たに追記されたタプルへのポインタが入ります。
レコードの更新履歴は、このt_ctidを辿ればすぐに判ります。
<br>
新たに追記したタプルのt_minに更新したトランザクションのXID(100)が書かれます。
また、このトランザクションによる１番めのコマンドなので、t_cidに1が書かれます。
</p>

<p>
これらを時系列に沿って描き直します([<図2-31>])。
</p>


<table border=1>
<caption>[<図2-31>] 追記型による同時実行制御の仕組み(1)</caption>
<tr><td>
<left>
<img src="./fig-2-06-05.jpg"><br>
</left>
</td></tr></table>


<blockquote>
<p>
(1) はじめに'A'というデータが書き込まれていた。
XID=100のトランザクションを開始し、SELECT文を実行すると'A'がみえる。
</p>

<p>
(2) 次にUPDATE文で値を'B'に更新すると、
古いデータ'A'を保存しているタプルのt_maxに更新したトランザクションのXID(100)を記入し、
新たにデータ'B'を保存するタプルを追記する。
</p>

<p>
(3) さらにUPDATE文で値を'C'に更新すると、またタプルを追記する。
同一トランザクション内でのSQL文はt_cidによって番号付けされ、区別する。
</p>

</blockquote>

<p>
以上、単一トランザクション内でのタプルの追記について簡単に説明しました。
<br>
ここまではタプルの追記に注目して説明するため、同時実行制御に必要なスナップショットとCLOG(コミットログ)を省略しました。
次に説明する複数トランザクションでのタプルの追記では、これらを省略することなくPostgreSQLの同時実行制御について説明します。
</p>


%SECTION 複数トランザクションにおける同時実行制御

<p>
複数トランザクションが実行されている状況での、PostgreSQLの同時実行制御について説明します([<図2-32>]参照)。
</p>


<table border=1>
<caption>[<図2-32>] 追記型による同時実行制御の仕組み(2)</caption>
<tr><td>
<left>
<img src="./fig-2-06-06.jpg"><br>
</left>
</td></tr></table>


<p>
はじめに、トランザクションの状態を保持するCLOG(コミットログ)とプロセステーブルについて説明します。
</p>

<p>
CLOGはトランザクション毎の状態(IN_PROGRESS, COMMITTED, ABORTED, SUB_COMMITTED)を保持します。
トランザクションの状態は、処理中は"IN_PROGRES"、COMMITすると"COMMITTED"、ABORTすると"ABORTED"となります。
SAVEPOINT設定中は"SUB_COMMITTED"です。
<br>
トランザクションが開始される度、CLOGに情報が追加されます。
CLOGに書き込まれた古い(FREEZEされた)XIDの情報は、VACUUM処理が削除します。
<br>
なお、CLOGはCHECKPOINT毎にデータベースクラスタのサブディレクトリpg_clog以下にファイルとして保存します。
</p>

<p>
プロセステーブルは、postgresプロセスが実行中のトランザクションIDを保持しています。
トランザクションが開始されると、XIDと(そのトランザクションの)開始時に、既に開いている全トランザクションのXIDを保存します。
これがそのトランザクションにとって最初のスナップショットになります。
</p>

<p>
例えば、XID=102のトランザクションが開始するとき、既にXID=101が開いているので、
XID=102のスナップショットにはXID=101と102が含まれます。
(XID=101は開始時に他のトランザクションが走っていないので、最初のスナップショットはXID=101だけである)
</p>

<p>
以下、具体的に２つのトランザクションによる同時実行制御を説明します。
</p>

<blockquote>
<p>
(1) XID=101と102の２つのトランザクションが開始した。
</p>

<p>
(2) XID=101のトランザクションがUPDATE文を実行した。
</p>

<p>
(3) その直後、XID＝102のトランザクション内でSELECT文を実行する。
<br>
その際、スナップショットから自分より古いトランザクション(XID=101)が進行中と判る。
XID=101はコミット前なので、その更新結果は表示できない。
よって検索結果はXID=101の更新前の 'C'を表示する。
</p>
</blockquote>

<p>
次に、XID=101のトランザクションがコミットした後の挙動を説明します。
</p>

<blockquote>
<p>
(4) XID=102のトランザクションがSELECT文を実行する。<br>
スナップショットを得ると、自分より古いトランザクションX=101はCOMMITTEDで終了したことがわかる。
ここで検索を行うが、XID=102の検索結果は自身の隔離レベルに依存する。
<br>
READ COMMITTEDなら、XID=101の結果を読むことができるので、検索結果は'D'となる。
<br>
しかしSERIALIZABLEなどはXID=101の更新を反映してはならないので、検索結果は'C'となる。
</p>

</blockquote>


%SECTION ビジビリティマップ(Visibility Map)

<p>
トランザクションの隔離を実現するには、
スナップショットを得てから、各タプルがそのトランザクション内で可視かどうかを逐次検査しなければなりません。
<br>
これは非常に手間のかかる処理ですが、
もしもブロック内に不要なタプルがひとつも存在せず、
且つどのトランザクションも更新していないなら、
そのブロックのタプルはすべて可視なので検査をスキップできます。
</>

<p>
そこでメモリ上、テーブルのブロックごとに1[bit]のデータ領域を確保し、
上記の条件(不要なタプルが存在しない && どのトランザクションも更新してない)を満たすブロックには"0"、
それ以外は"1"を保存する機能がバージョン8.4でサポートされました([<脚注20>])。
これをビジビリティマップ(Visibility Map)と呼びます。
<br>
このビジビリティマップを利用してトランザクション内の可視の検査を効率化できます。
<br>
また、バージョン9.2でサポートするIndex-Only Scan([<2-08>])でも重要な役割を担っています。
</p>


<blockquote><table BORDER="1"><tr><td>脚注20</td><td>
<p>
テーブルの先頭ブロックから順に1[bit]づつ割り当てるので、確保する領域も非常に小さく、またブロック検索も効率的にできます。
</p>
</td></tr></table></blockquote>


<p>
なお、データベースクラスタ内にはテーブルファイルXXXに対してXXX_vmというファイルが存在します。
これはテーブル毎にメモリ上のビジビリティマップのデータをファイルとして保存しているものです。
<br>
例えばテーブルsimpletblは、テーブルデータを保存するファイル"18740"とビジビリティマップファイル"18740_vm"を持ちます。
</p>

<pre>
postgres> ls -la 18740 18740_vm 
-rw------- 1 postgres users 8192 Mar 23 14:09 18740
-rw------- 1 postgres users 8192 Mar 23 14:13 18740_vm
</pre>


</font>



%CHAPTER 参考文献

<ol>
<li>PostgreSQL解析資料 MVCC	井久保氏</li>
http://ikubo.x0.com/PostgreSQL/pdf/IK09-mvcc.pdf
</ol>

